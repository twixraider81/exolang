/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

header {
	#include "exo/exo.h"
}

start = EXO;


/* TODO: verbatim copy quex/code_base/token/CppDefault.qx should export it somehow pls */
token_type {
   header {
$INCLUDE_CONVERTER_DECLARATION
   }

   standard {
        id            : uint32_t;
        line_number   : size_t;
        column_number : size_t;
   }

   distinct {
       text		: std::basic_string<QUEX_TYPE_CHARACTER>;
       lValue	: long long;
       dValue	: double;
       typeId	: ushort;
   }

   inheritable;

   copy {
        self._id    = Other._id;
        self.text   = Other.text;
        self.lValue = Other.lValue;
        self.dValue = Other.dValue;
        self.typeId = Other.typeId;
		self._line_n = Other._line_n;
        self._column_n = Other._column_n;
   }

   body {
        typedef std::basic_string<QUEX_TYPE_CHARACTER> __string;

        operator 
        const std::string() const
        { return get_string(); }

        const std::string
        get_string() const 
        {
            std::string             tmp;

            tmp = map_id_to_name(self._id);

            tmp += " '" + pretty_char_text() + "' ";

            return tmp;
        }
    
        const std::string 
        pretty_char_text() const
        /* Provides a somehow pretty-print of the text in the token. */
        {
            std::string             tmp = $CONVERTER_STRING(self.text);
            std::string::size_type  pos = 0;

            while( (pos = tmp.find("\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\n");
            while( (pos = tmp.find("\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\t");
            while( (pos = tmp.find("\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\r");

            return tmp;
        }

		const char* get_name()
		{
			switch( self._id )
			{
				default:
					return( "unknown token" );

				case QUEX_TKN_UNINITIALIZED:
					return( "uninitilized token" );

				case QUEX_TKN_TERMINATION:
					return( "end of file" );

				case QUEX_TKN_I_INT:
					return( "integer number" );

				case QUEX_TKN_F_FLOAT:
					return( "float number" );

				case QUEX_TKN_S_ADD:
					return( "+" );

				case QUEX_TKN_S_SUB:
					return( "-" );

				case QUEX_TKN_S_MUL:
					return( "*" );

				case QUEX_TKN_S_DIV:
					return( "/" );

				case QUEX_TKN_S_ASSIGN:
					return( "=" );

				case QUEX_TKN_S_SEMICOLON:
					return( ";" );

				case QUEX_TKN_T_VARIABLE:
					return( "variable" );

				case QUEX_TKN_T_LABEL:
					return( "label" );

				case QUEX_TKN_S_ABRACKET_OPEN:
					return( "(" );

				case QUEX_TKN_S_ABRACKET_CLOSE:
					return( ")" );

				case QUEX_TKN_T_TYPE_INT:
					return( "int" );

				case QUEX_TKN_T_TYPE_FLOAT:
					return( "float" );

				case QUEX_TKN_T_TYPE_BOOLEAN:
					return( "boolean" );

				case QUEX_TKN_T_TYPE_AUTO:
					return( "auto/mixed" );

				case QUEX_TKN_T_TYPE_STRING:
					return( "string" );
				
				case QUEX_TKN_T_TYPE_NULL:
					return( "null" );
			}
		}
   }

   take_text {
        /* It cannot be assumed that the lexeme is zero terminated. */
        __quex_assert(End >= Begin);
        self.text.assign(Begin, End-Begin);

        /* This token copied the text from the chunk into the string, 
         * so we do not claim owneship over it.                       */
        return false;      
   }

   repetition_set {
       self.number = N;
   }

   repetition_get {
       return self.number;
   }

   footer {
        $NAMESPACE_OPEN
        inline std::ostream&
        operator<<(std::ostream& ostr, const $TOKEN_CLASS& Tok)
        { ostr << Tok.get_string(); return ostr; }
        $NAMESPACE_CLOSE

$INCLUDE_CONVERTER_IMPLEMENTATION
   }
}



mode EXO:
<skip:       [ \r\n\t]>		/* skip whitespace */
<skip_range: "/*" "*/">		/* skip multiline comments */
<skip_range: "//" "\n">		/* skip singleline comments */
<skip_range: "#" "\n">		/* skip singleline comments */
{
	"null"							=> QUEX_TKN_T_TYPE_NULL;
	"nil"							=> QUEX_TKN_T_TYPE_NULL;
	"bool"							=> QUEX_TKN_T_TYPE_BOOLEAN;
	"boolean"						=> QUEX_TKN_T_TYPE_BOOLEAN;
	"int"							=> QUEX_TKN_T_TYPE_INT;
	"integer"						=> QUEX_TKN_T_TYPE_INT;
	"float"							=> QUEX_TKN_T_TYPE_FLOAT;
	"string"						=> QUEX_TKN_T_TYPE_STRING;
	"auto"							=> QUEX_TKN_T_TYPE_AUTO;
	[0-9]+							=> QUEX_TKN_I_INT( lValue = atoi( reinterpret_cast<const char*>(Lexeme) ) );
	([0-9]+[.,][0-9]*)				=> QUEX_TKN_F_FLOAT( dValue = atof( reinterpret_cast<const char*>(Lexeme) ) );
	"$"([_a-zA-Z]+[_a-zA-Z0-9]*)	=> QUEX_TKN_T_VARIABLE(LexemeBegin+1,LexemeEnd);
	([_a-zA-Z\\]+[_a-zA-Z\\0-9]*)	=> QUEX_TKN_T_LABEL(LexemeBegin+1,LexemeEnd);
	"+"								=> QUEX_TKN_S_ADD;
	"-"								=> QUEX_TKN_S_SUB;
	"*"								=> QUEX_TKN_S_MUL;
	"/"								=> QUEX_TKN_S_DIV;
	"="								=> QUEX_TKN_S_ASSIGN;
	";"								=> QUEX_TKN_S_SEMICOLON;
	"("								=> QUEX_TKN_S_ABRACKET_OPEN;
	")"								=> QUEX_TKN_S_ABRACKET_CLOSE;

	<<EOF>>							=> QUEX_TKN_TERMINATION;

	<<FAIL>> {
		ERRORMSG( "unknown token: " << Lexeme );
	}
}